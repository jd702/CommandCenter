{"ast":null,"code":"import React, { cloneElement, isValidElement, useEffect, useMemo, useRef, useState } from \"react\";\nimport { addToQueue, clearQueue, clearQueueHook, clearQueueUnload, dequeue, removeFromQueue, speakFromQueue, subscribe } from \"./queue.js\";\nimport { ArrayToText, cancel, findCharIndex, getIndex, isMobile, isParent, JSXToArray, sanitize, TextToChunks } from \"./utils.js\";\nexport function useQueue() {\n  const [queue, setQueue] = useState([]);\n  useEffect(() => subscribe(setQueue), []);\n  return {\n    queue,\n    dequeue,\n    clearQueue: clearQueueHook\n  };\n}\nexport function useSpeech({\n  text,\n  pitch = 1,\n  rate = 1,\n  volume = 1,\n  lang,\n  voiceURI,\n  highlightText = false,\n  highlightProps,\n  preserveUtteranceQueue = false,\n  onError = console.error,\n  onStart,\n  onResume,\n  onPause,\n  onStop,\n  onBoundary,\n  onQueueChange\n}) {\n  const [speechStatus, speechStatusRef, setSpeechStatus] = useStateRef(\"stopped\");\n  const [speakingWord, setSpeakingWord] = useState();\n  const utteranceRef = useRef();\n  const {\n    voices\n  } = useVoices();\n  const [words, stringifiedWords] = useMemo(() => {\n    const words = JSXToArray(text);\n    return [words, JSON.stringify(words)];\n  }, [text]);\n  function start() {\n    const synth = window.speechSynthesis;\n    if (!synth) return onError(new Error(\"Browser not supported! Try some other browser.\"));\n    if (speechStatus === \"paused\") return synth.resume();\n    if (speechStatus === \"queued\") return;\n    const chunks = TextToChunks(sanitize(ArrayToText(words)));\n    const numChunks = chunks.length;\n    let currentChunk = 0,\n      offset = 0;\n    const utterance = new SpeechSynthesisUtterance(chunks[currentChunk]);\n    utterance.pitch = pitch;\n    utterance.rate = rate;\n    utterance.volume = volume;\n    if (lang) utterance.lang = lang;\n    if (voiceURI) {\n      if (!Array.isArray(voiceURI)) voiceURI = [voiceURI];\n      for (let i = 0; i < voiceURI.length; i++) {\n        const uri = voiceURI[i];\n        const voice = voices.find(voice => voice.voiceURI === uri);\n        if (voice) {\n          utterance.voice = voice;\n          break;\n        }\n      }\n    }\n    const stopEventHandler = event => {\n      if (event.type === \"end\" && currentChunk < numChunks - 1) {\n        offset += chunks[currentChunk].length;\n        utterance.text = chunks[++currentChunk];\n        return speakFromQueue();\n      }\n      if (synth.paused) cancel();\n      window.removeEventListener(\"beforeunload\", clearQueueUnload);\n      setSpeechStatus(\"stopped\");\n      setSpeakingWord(null);\n      utterance.onstart = null;\n      utterance.onresume = null;\n      utterance.onpause = null;\n      utterance.onend = null;\n      utterance.onerror = null;\n      utterance.onboundary = null;\n      removeFromQueue(utterance, onQueueChange);\n      speakFromQueue();\n      onStop === null || onStop === void 0 ? void 0 : onStop(event);\n    };\n    utterance.onstart = event => {\n      window.addEventListener(\"beforeunload\", clearQueueUnload);\n      setSpeechStatus(\"started\");\n      onStart === null || onStart === void 0 ? void 0 : onStart(event);\n    };\n    utterance.onresume = event => {\n      setSpeechStatus(\"started\");\n      onResume === null || onResume === void 0 ? void 0 : onResume(event);\n    };\n    utterance.onpause = event => {\n      setSpeechStatus(\"paused\");\n      onPause === null || onPause === void 0 ? void 0 : onPause(event);\n    };\n    utterance.onend = stopEventHandler;\n    utterance.onerror = stopEventHandler;\n    utterance.onboundary = event => {\n      setSpeakingWord({\n        index: findCharIndex(words, offset + event.charIndex),\n        length: event.charLength\n      });\n      onBoundary === null || onBoundary === void 0 ? void 0 : onBoundary(event);\n    };\n    if (!preserveUtteranceQueue) clearQueue();\n    addToQueue({\n      utterance,\n      setSpeechStatus\n    }, onQueueChange);\n    if (synth.speaking) {\n      if (preserveUtteranceQueue && speechStatus !== \"started\") {\n        utteranceRef.current = utterance;\n        return setSpeechStatus(\"queued\");\n      } else cancel();\n    } else speakFromQueue();\n    setSpeechStatus(\"started\");\n  }\n  function pause() {\n    var _a;\n    if (isMobile(false) || speechStatus === \"queued\") return stop();\n    if (speechStatus === \"started\") (_a = window.speechSynthesis) === null || _a === void 0 ? void 0 : _a.pause();\n  }\n  function stop(status = speechStatus) {\n    if (status === \"stopped\") return;\n    if (status !== \"queued\") return cancel();\n    removeFromQueue(utteranceRef.current, onQueueChange);\n    setSpeechStatus(\"stopped\");\n  }\n  function highlightedText(element, parentIndex = \"\") {\n    var _a;\n    if (!highlightText || !isParent(parentIndex, speakingWord === null || speakingWord === void 0 ? void 0 : speakingWord.index)) return element;\n    if (Array.isArray(element)) return element.map((child, index) => highlightedText(child, getIndex(parentIndex, index)));\n    if (isValidElement(element)) return cloneElement(element, {\n      key: (_a = element.key) !== null && _a !== void 0 ? _a : Math.random()\n    }, highlightedText(element.props.children, parentIndex));\n    if (typeof element === \"string\" || typeof element === \"number\") {\n      element = String(element);\n      const {\n        index,\n        length\n      } = speakingWord;\n      const before = element.slice(0, +index.split(\"-\").at(-1)).length;\n      return React.createElement(\"span\", {\n        key: index\n      }, element.slice(0, before), React.createElement(\"mark\", Object.assign({}, highlightProps), element.slice(before, before + length)), element.slice(before + length));\n    }\n    return element;\n  }\n  useEffect(() => {\n    return () => stop(speechStatusRef.current);\n  }, [stringifiedWords]);\n  return {\n    Text: () => highlightedText(text),\n    speechStatus,\n    isInQueue: speechStatus === \"started\" || speechStatus === \"queued\",\n    start,\n    pause,\n    stop: () => stop()\n  };\n}\nfunction useStateRef(init) {\n  const [state, setState] = useState(init);\n  const ref = useRef(init);\n  function setStateRef(value) {\n    ref.current = value;\n    setState(value);\n  }\n  return [state, ref, setStateRef];\n}\nexport function useVoices() {\n  const [languages, setLanguages] = useState([]);\n  const [voices, setVoices] = useState([]);\n  function setData(voices) {\n    setLanguages([...new Set(voices.map(({\n      lang\n    }) => lang))]);\n    setVoices(voices);\n  }\n  useEffect(() => {\n    const synth = window.speechSynthesis;\n    if (!synth) return;\n    const voices = synth.getVoices();\n    if (voices.length) setData(voices);else {\n      const onVoicesChanged = () => setData(synth.getVoices());\n      synth.addEventListener(\"voiceschanged\", onVoicesChanged);\n      return () => synth.removeEventListener(\"voiceschanged\", onVoicesChanged);\n    }\n  }, []);\n  return {\n    languages,\n    voices\n  };\n}","map":{"version":3,"names":["React","cloneElement","isValidElement","useEffect","useMemo","useRef","useState","addToQueue","clearQueue","clearQueueHook","clearQueueUnload","dequeue","removeFromQueue","speakFromQueue","subscribe","ArrayToText","cancel","findCharIndex","getIndex","isMobile","isParent","JSXToArray","sanitize","TextToChunks","useQueue","queue","setQueue","useSpeech","text","pitch","rate","volume","lang","voiceURI","highlightText","highlightProps","preserveUtteranceQueue","onError","console","error","onStart","onResume","onPause","onStop","onBoundary","onQueueChange","speechStatus","speechStatusRef","setSpeechStatus","useStateRef","speakingWord","setSpeakingWord","utteranceRef","voices","useVoices","words","stringifiedWords","JSON","stringify","start","synth","window","speechSynthesis","Error","resume","chunks","numChunks","length","currentChunk","offset","utterance","SpeechSynthesisUtterance","Array","isArray","i","uri","voice","find","stopEventHandler","event","type","paused","removeEventListener","onstart","onresume","onpause","onend","onerror","onboundary","addEventListener","index","charIndex","charLength","speaking","current","pause","_a","stop","status","highlightedText","element","parentIndex","map","child","key","Math","random","props","children","String","before","slice","split","at","createElement","Object","assign","Text","isInQueue","init","state","setState","ref","setStateRef","value","languages","setLanguages","setVoices","setData","Set","getVoices","onVoicesChanged"],"sources":["C:/Users/jelan/Downloads/stream-ui/node_modules/react-text-to-speech/dist/hooks.js"],"sourcesContent":["import React, { cloneElement, isValidElement, useEffect, useMemo, useRef, useState } from \"react\";\nimport { addToQueue, clearQueue, clearQueueHook, clearQueueUnload, dequeue, removeFromQueue, speakFromQueue, subscribe } from \"./queue.js\";\nimport { ArrayToText, cancel, findCharIndex, getIndex, isMobile, isParent, JSXToArray, sanitize, TextToChunks } from \"./utils.js\";\nexport function useQueue() {\n    const [queue, setQueue] = useState([]);\n    useEffect(() => subscribe(setQueue), []);\n    return { queue, dequeue, clearQueue: clearQueueHook };\n}\nexport function useSpeech({ text, pitch = 1, rate = 1, volume = 1, lang, voiceURI, highlightText = false, highlightProps, preserveUtteranceQueue = false, onError = console.error, onStart, onResume, onPause, onStop, onBoundary, onQueueChange, }) {\n    const [speechStatus, speechStatusRef, setSpeechStatus] = useStateRef(\"stopped\");\n    const [speakingWord, setSpeakingWord] = useState();\n    const utteranceRef = useRef();\n    const { voices } = useVoices();\n    const [words, stringifiedWords] = useMemo(() => {\n        const words = JSXToArray(text);\n        return [words, JSON.stringify(words)];\n    }, [text]);\n    function start() {\n        const synth = window.speechSynthesis;\n        if (!synth)\n            return onError(new Error(\"Browser not supported! Try some other browser.\"));\n        if (speechStatus === \"paused\")\n            return synth.resume();\n        if (speechStatus === \"queued\")\n            return;\n        const chunks = TextToChunks(sanitize(ArrayToText(words)));\n        const numChunks = chunks.length;\n        let currentChunk = 0, offset = 0;\n        const utterance = new SpeechSynthesisUtterance(chunks[currentChunk]);\n        utterance.pitch = pitch;\n        utterance.rate = rate;\n        utterance.volume = volume;\n        if (lang)\n            utterance.lang = lang;\n        if (voiceURI) {\n            if (!Array.isArray(voiceURI))\n                voiceURI = [voiceURI];\n            for (let i = 0; i < voiceURI.length; i++) {\n                const uri = voiceURI[i];\n                const voice = voices.find((voice) => voice.voiceURI === uri);\n                if (voice) {\n                    utterance.voice = voice;\n                    break;\n                }\n            }\n        }\n        const stopEventHandler = (event) => {\n            if (event.type === \"end\" && currentChunk < numChunks - 1) {\n                offset += chunks[currentChunk].length;\n                utterance.text = chunks[++currentChunk];\n                return speakFromQueue();\n            }\n            if (synth.paused)\n                cancel();\n            window.removeEventListener(\"beforeunload\", clearQueueUnload);\n            setSpeechStatus(\"stopped\");\n            setSpeakingWord(null);\n            utterance.onstart = null;\n            utterance.onresume = null;\n            utterance.onpause = null;\n            utterance.onend = null;\n            utterance.onerror = null;\n            utterance.onboundary = null;\n            removeFromQueue(utterance, onQueueChange);\n            speakFromQueue();\n            onStop === null || onStop === void 0 ? void 0 : onStop(event);\n        };\n        utterance.onstart = (event) => {\n            window.addEventListener(\"beforeunload\", clearQueueUnload);\n            setSpeechStatus(\"started\");\n            onStart === null || onStart === void 0 ? void 0 : onStart(event);\n        };\n        utterance.onresume = (event) => {\n            setSpeechStatus(\"started\");\n            onResume === null || onResume === void 0 ? void 0 : onResume(event);\n        };\n        utterance.onpause = (event) => {\n            setSpeechStatus(\"paused\");\n            onPause === null || onPause === void 0 ? void 0 : onPause(event);\n        };\n        utterance.onend = stopEventHandler;\n        utterance.onerror = stopEventHandler;\n        utterance.onboundary = (event) => {\n            setSpeakingWord({ index: findCharIndex(words, offset + event.charIndex), length: event.charLength });\n            onBoundary === null || onBoundary === void 0 ? void 0 : onBoundary(event);\n        };\n        if (!preserveUtteranceQueue)\n            clearQueue();\n        addToQueue({ utterance, setSpeechStatus }, onQueueChange);\n        if (synth.speaking) {\n            if (preserveUtteranceQueue && speechStatus !== \"started\") {\n                utteranceRef.current = utterance;\n                return setSpeechStatus(\"queued\");\n            }\n            else\n                cancel();\n        }\n        else\n            speakFromQueue();\n        setSpeechStatus(\"started\");\n    }\n    function pause() {\n        var _a;\n        if (isMobile(false) || speechStatus === \"queued\")\n            return stop();\n        if (speechStatus === \"started\")\n            (_a = window.speechSynthesis) === null || _a === void 0 ? void 0 : _a.pause();\n    }\n    function stop(status = speechStatus) {\n        if (status === \"stopped\")\n            return;\n        if (status !== \"queued\")\n            return cancel();\n        removeFromQueue(utteranceRef.current, onQueueChange);\n        setSpeechStatus(\"stopped\");\n    }\n    function highlightedText(element, parentIndex = \"\") {\n        var _a;\n        if (!highlightText || !isParent(parentIndex, speakingWord === null || speakingWord === void 0 ? void 0 : speakingWord.index))\n            return element;\n        if (Array.isArray(element))\n            return element.map((child, index) => highlightedText(child, getIndex(parentIndex, index)));\n        if (isValidElement(element))\n            return cloneElement(element, { key: (_a = element.key) !== null && _a !== void 0 ? _a : Math.random() }, highlightedText(element.props.children, parentIndex));\n        if (typeof element === \"string\" || typeof element === \"number\") {\n            element = String(element);\n            const { index, length } = speakingWord;\n            const before = element.slice(0, +index.split(\"-\").at(-1)).length;\n            return (React.createElement(\"span\", { key: index },\n                element.slice(0, before),\n                React.createElement(\"mark\", Object.assign({}, highlightProps), element.slice(before, before + length)),\n                element.slice(before + length)));\n        }\n        return element;\n    }\n    useEffect(() => {\n        return () => stop(speechStatusRef.current);\n    }, [stringifiedWords]);\n    return {\n        Text: () => highlightedText(text),\n        speechStatus,\n        isInQueue: speechStatus === \"started\" || speechStatus === \"queued\",\n        start,\n        pause,\n        stop: () => stop(),\n    };\n}\nfunction useStateRef(init) {\n    const [state, setState] = useState(init);\n    const ref = useRef(init);\n    function setStateRef(value) {\n        ref.current = value;\n        setState(value);\n    }\n    return [state, ref, setStateRef];\n}\nexport function useVoices() {\n    const [languages, setLanguages] = useState([]);\n    const [voices, setVoices] = useState([]);\n    function setData(voices) {\n        setLanguages([...new Set(voices.map(({ lang }) => lang))]);\n        setVoices(voices);\n    }\n    useEffect(() => {\n        const synth = window.speechSynthesis;\n        if (!synth)\n            return;\n        const voices = synth.getVoices();\n        if (voices.length)\n            setData(voices);\n        else {\n            const onVoicesChanged = () => setData(synth.getVoices());\n            synth.addEventListener(\"voiceschanged\", onVoicesChanged);\n            return () => synth.removeEventListener(\"voiceschanged\", onVoicesChanged);\n        }\n    }, []);\n    return { languages, voices };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}