{"ast":null,"code":"import { isValidElement } from \"react\";\nexport function ArrayToText(element) {\n  if (typeof element === \"string\") return element;\n  return element.map(ArrayToText).join(\" \") + \" \";\n}\nexport function JSXToArray(element) {\n  if (isValidElement(element)) {\n    const {\n      children\n    } = element.props;\n    if (Array.isArray(children)) return children.map(JSXToArray);\n    return JSXToArray(children);\n  }\n  return typeof element === \"string\" ? element : typeof element === \"number\" ? String(element) : \"\";\n}\nexport function cancel() {\n  var _a;\n  if (typeof window !== \"undefined\") (_a = window.speechSynthesis) === null || _a === void 0 ? void 0 : _a.cancel();\n}\nexport function TextToChunks(text) {\n  let desktopSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n  let mobileSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 250;\n  const length = text.length;\n  const size = isMobile() ? mobileSize : desktopSize;\n  const result = [];\n  let startIndex = 0;\n  while (startIndex < length) {\n    let endIndex = Math.min(startIndex + size, length);\n    if (endIndex < length && text[endIndex] !== \" \") {\n      const spaceIndex = text.lastIndexOf(\" \", endIndex);\n      if (spaceIndex > startIndex) endIndex = spaceIndex;\n    }\n    result.push(text.slice(startIndex, endIndex));\n    startIndex = endIndex;\n  }\n  return result;\n}\nexport function findCharIndex(words, index) {\n  let currentIndex = 0;\n  function recursiveSearch(stringArray) {\n    let parentIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    if (typeof stringArray === \"string\") {\n      const elementIndex = index - currentIndex;\n      return (currentIndex += stringArray.length + 1) > index ? getIndex(parentIndex, elementIndex) : \"\";\n    }\n    for (let i = 0; i < stringArray.length; i++) {\n      const element = stringArray[i];\n      const result = recursiveSearch(element, i);\n      if (result) return getIndex(parentIndex, result);\n    }\n    currentIndex++;\n    return \"\";\n  }\n  return recursiveSearch(words);\n}\nexport const getIndex = (parentIndex, index) => `${parentIndex === \"\" ? \"\" : parentIndex + \"-\"}${index}`;\nexport function isMobile() {\n  let iOS = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var _a;\n  let result = (_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.mobile;\n  result !== null && result !== void 0 ? result : result = /Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || iOS && /iPhone|iPad|iPod/i.test(navigator.userAgent);\n  return result;\n}\nexport function isParent(parentIndex, index) {\n  if (!(index === null || index === void 0 ? void 0 : index.startsWith(parentIndex))) return false;\n  if (parentIndex) {\n    const indexParts = index.split(\"-\");\n    const parentIndexParts = parentIndex.split(\"-\");\n    for (let i = 0; i < parentIndexParts.length; i++) {\n      if (indexParts[i] !== parentIndexParts[i]) return false;\n    }\n  }\n  return true;\n}\nexport const sanitize = text => text.replace(/[<>]|(&[^\\s;]+);/g, (match, group) => match === \"<\" ? \"(\" : (group || \"\") + \")\");","map":{"version":3,"names":["isValidElement","ArrayToText","element","map","join","JSXToArray","children","props","Array","isArray","String","cancel","_a","window","speechSynthesis","TextToChunks","text","desktopSize","arguments","length","undefined","mobileSize","size","isMobile","result","startIndex","endIndex","Math","min","spaceIndex","lastIndexOf","push","slice","findCharIndex","words","index","currentIndex","recursiveSearch","stringArray","parentIndex","elementIndex","getIndex","i","iOS","navigator","userAgentData","mobile","test","userAgent","isParent","startsWith","indexParts","split","parentIndexParts","sanitize","replace","match","group"],"sources":["C:/Users/jelan/Downloads/stream-ui/node_modules/react-text-to-speech/dist/utils.js"],"sourcesContent":["import { isValidElement } from \"react\";\nexport function ArrayToText(element) {\n    if (typeof element === \"string\")\n        return element;\n    return element.map(ArrayToText).join(\" \") + \" \";\n}\nexport function JSXToArray(element) {\n    if (isValidElement(element)) {\n        const { children } = element.props;\n        if (Array.isArray(children))\n            return children.map(JSXToArray);\n        return JSXToArray(children);\n    }\n    return typeof element === \"string\" ? element : typeof element === \"number\" ? String(element) : \"\";\n}\nexport function cancel() {\n    var _a;\n    if (typeof window !== \"undefined\")\n        (_a = window.speechSynthesis) === null || _a === void 0 ? void 0 : _a.cancel();\n}\nexport function TextToChunks(text, desktopSize = 1000, mobileSize = 250) {\n    const length = text.length;\n    const size = isMobile() ? mobileSize : desktopSize;\n    const result = [];\n    let startIndex = 0;\n    while (startIndex < length) {\n        let endIndex = Math.min(startIndex + size, length);\n        if (endIndex < length && text[endIndex] !== \" \") {\n            const spaceIndex = text.lastIndexOf(\" \", endIndex);\n            if (spaceIndex > startIndex)\n                endIndex = spaceIndex;\n        }\n        result.push(text.slice(startIndex, endIndex));\n        startIndex = endIndex;\n    }\n    return result;\n}\nexport function findCharIndex(words, index) {\n    let currentIndex = 0;\n    function recursiveSearch(stringArray, parentIndex = \"\") {\n        if (typeof stringArray === \"string\") {\n            const elementIndex = index - currentIndex;\n            return (currentIndex += stringArray.length + 1) > index ? getIndex(parentIndex, elementIndex) : \"\";\n        }\n        for (let i = 0; i < stringArray.length; i++) {\n            const element = stringArray[i];\n            const result = recursiveSearch(element, i);\n            if (result)\n                return getIndex(parentIndex, result);\n        }\n        currentIndex++;\n        return \"\";\n    }\n    return recursiveSearch(words);\n}\nexport const getIndex = (parentIndex, index) => `${parentIndex === \"\" ? \"\" : parentIndex + \"-\"}${index}`;\nexport function isMobile(iOS = true) {\n    var _a;\n    let result = (_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.mobile;\n    result !== null && result !== void 0 ? result : (result = /Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (iOS && /iPhone|iPad|iPod/i.test(navigator.userAgent)));\n    return result;\n}\nexport function isParent(parentIndex, index) {\n    if (!(index === null || index === void 0 ? void 0 : index.startsWith(parentIndex)))\n        return false;\n    if (parentIndex) {\n        const indexParts = index.split(\"-\");\n        const parentIndexParts = parentIndex.split(\"-\");\n        for (let i = 0; i < parentIndexParts.length; i++) {\n            if (indexParts[i] !== parentIndexParts[i])\n                return false;\n        }\n    }\n    return true;\n}\nexport const sanitize = (text) => text.replace(/[<>]|(&[^\\s;]+);/g, (match, group) => (match === \"<\" ? \"(\" : (group || \"\") + \")\"));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}